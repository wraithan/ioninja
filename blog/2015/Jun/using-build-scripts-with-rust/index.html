<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Iron Oxide Ninja, Wraithan's dev blog">
    <meta name="author" content="Wraithan">
    
    <title>Using Build Scripts with Rust - Iron Oxide Ninja</title>

    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/default.min.css">    
    <link href="/css/highlight/railscasts.css" rel="stylesheet">
    <link href="/css/base.css" rel="stylesheet">
  </head>
  <body>
    <nav class="navbar navbar-default navbar-static-top">
      <div class="container">
        <div class="row">
          <div class="col-md-10 col-md-offset-1">
            <div class="navbar-header">
              <a class="navbar-brand" href="/">Iron Oxide Ninja</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
              <ul class="nav navbar-nav navbar-right">
                <li><a href="/about/">About</a></li>
                <li><a href="https://github.com/wraithan">GitHub</a></li>
               </ul>
            </div><!-- /.navbar-collapse -->
          </div><!-- /.container -->
        </div>
      </div>
    </nav>
    <div class="container">

      <div class="row">
        <div class="col-md-10 col-md-offset-1">
          <div class="row">
            <div class="col-md-12">
              <div class="page-header text-center">
                 
<h2>Using Build Scripts with Rust</h2>
<p>
  Written on: June 14th, 2015
  
</p>

              </div>
            </div>
          </div>

          <div class="row">
            <div class="col-sm-8">
              
<p>Last week I started into writing another <a href="http://aigames.com/competitions/warlight-ai-challenge-2">Warlight AI Challenge</a> bot. I definitely wanted to write the bot in Rust since it was now 1.0 and it makes sense to get the competition runners to support it. I had already written one bot in Node but wanted to see what the static approach (especially with Rust&#39;s ownership model) would yield.</p>
<p>I wanted to import the test harness that <a href="http://curiousattemptbunny.com/">Curious Attempt Bunny</a> came up with when building his clojure bot. The <a href="https://github.com/curious-attempt-bunny/warlight2-starterbot-clojure#create-new-tests">spec</a> for the tests is simple enough and it makes the tests portable across engines. This means I can import my tests from <a href="https://github.com/wraithan/zenwarbot/tree/master/test/fodder">ZenWarBot</a> to bootstrap my new bot <a href="https://github.com/wraithan/rust-war-bot">rust-war-bot</a>. The first problem I ran into though was that there was no way to dynamically define tests for <code>cargo test</code> to pick up and run.</p>
<p>I found my way over to <a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">#rust on irc.mozilla.org</a> and someone suggested the because the <a href="http://doc.crates.io/build-script.html#case-study:-code-generation">docs for build scripts</a> mentioned dynamically generating code then importing it. This seemed like the ticket for me.</p>
<p>I added <code>build = &quot;build.rs&quot;</code> to my Cargo.toml file and then opened <code>build.rs</code> up and pasted in the example code from the docs.</p>
<pre><code class="lang-rust">// build.rs

use std::env;
use std::fs::File;
use std::io::Write;
use std::path::Path;

fn main() {
    let out_dir = env::var(&quot;OUT_DIR&quot;).unwrap();
    let dest_path = Path::new(&amp;out_dir).join(&quot;hello.rs&quot;);
    let mut f = File::create(&amp;dest_path).unwrap();

    f.write_all(b&quot;
        pub fn message() -&gt; &amp;&#39;static str {
            \&quot;Hello, World!\&quot;
        }
    &quot;).unwrap();
}
</code></pre>
<p>Note this is being built as an executable and therefore needs a <code>fn main()</code>. This loads in an environment variable that Cargo sets before running your build script. <code>OUT_DIR</code> as its name implies is where all build output should be placed. This <code>OUT_DIR</code> variable is also available to your application or library while it is being build as we&#39;ll see in their example:</p>
<pre><code class="lang-rust">// src/main.rs

include!(concat!(env!(&quot;OUT_DIR&quot;), &quot;/hello.rs&quot;));

fn main() {
    println!(&quot;{}&quot;, message());
}
</code></pre>
<p>Which uses <code>env!</code> to load in the environment variable, <code>concat!</code> to load in the file, then <code>include!</code> to output the string it was handed into the file. This is all well and good and you could have read it in the docs as well, but I want to reference it as a starting point that I moved from then added onto.</p>
<p>My goal was to load in the names of all the files matching a pattern in a specific folder and create a test for each of them. To make this easier I decided to use the <a href="https://crates.io/crates/glob">glob</a> crate. So I added it to my Cargo.toml under <code>[dependencies]</code> and then added <code>extern crate glob;</code> to my <code>build.rs</code> but it didn&#39;t build. <code>build.rs</code> couldn&#39;t find the glob crate!</p>
<p>It turns out that if I&#39;d read the whole page for build scripts instead of just the section that had directly what I wanted, I would have known that <a href="http://doc.crates.io/build-script.html#build-dependencies"><code>build-dependencies</code></a> was what I wanted. So adding it there totally worked and I was trucking along.</p>
<p>I built out my <code>build.rs</code> to load in the file names and write out tests like so:</p>
<pre><code class="lang-rust">// build.rs

extern crate glob;

use std::env;
use std::fs::File;
use std::io::Write;
use std::path::Path;
use glob::glob;


fn main() {
    let out_dir = env::var(&quot;OUT_DIR&quot;).unwrap();
    // changed to tests.rs
    let dest_path = Path::new(&amp;out_dir).join(&quot;tests.rs&quot;);
    let mut f = File::create(&amp;dest_path).unwrap();

    for path in glob(&quot;tests/fodder/*.txt&quot;).unwrap() {
        writeln!(
            &amp;mut f,
            // this is the test definition
            &quot;#[test]\nfn {0}() {{assert!(true);}}&quot;,
            path.unwrap().file_stem().unwrap().to_str().unwrap()
        ).unwrap();
    }
}
</code></pre>
<p>So the <code>glob(&quot;tests/fodder/*.txt)</code> is pretty self explanatory. It returns a <code>Result&lt;Paths, PatternError&gt;</code>, I wanted my script to panic on error so I added <code>.unwrap()</code> because if that pattern fails, I want my build to fail. I iterate over the paths, grabbing the <code>file_stem</code> which is simply the portion of the file name before the extension. Then I convert it to a regular <code>str</code> from <code>OsStr</code> so it can be written to a file. Again, I&#39;m just tossing <code>.unwrap()</code> on everything because I want this to crash on failure of any of these parts.</p>
<p>And I wrote a <code>tests/runner.rs</code> to import those tests which consisted entirely of:</p>
<pre><code class="lang-rust">// tests/runner.rs

include!(concat!(env!(&quot;OUT_DIR&quot;), &quot;/tests.rs&quot;));
</code></pre>
<p>Then I ran <code>cargo test</code> and sure enough it created tests for each of the specs! Next part took a little thinking. I started to write out my test logic directly into my <code>build.rs</code> but that was tedious because it was in a string so I didn&#39;t have syntax highlighting, among other troubles. Also, I had considered reading in the contents of the specs in the <code>build.rs</code> then just injecting them as strings into the test. I decided took a little bit of time and rethought things and decided that instead of doing a bunch of work in <code>build.rs</code> I&#39;ll just have it call a function with the file name in the test!</p>
<p>Next (and final) iteration of <code>build.rs</code> looks likes this:</p>
<pre><code class="lang-rust">// build.rs

extern crate glob;

use std::env;
use std::fs::File;
use std::io::Write;
use std::path::Path;
use glob::glob;


fn main() {
    let out_dir = env::var(&quot;OUT_DIR&quot;).unwrap();
    let dest_path = Path::new(&amp;out_dir).join(&quot;tests.rs&quot;);
    let mut f = File::create(&amp;dest_path).unwrap();

    for path in glob(&quot;tests/fodder/*.txt&quot;).unwrap() {
        writeln!(
            &amp;mut f,
            &quot;#[test]\nfn {0}() {{run_file(\&quot;{0}\&quot;);}}&quot;,
            path.unwrap().file_stem().unwrap().to_str().unwrap()
        ).unwrap();
    }
}
</code></pre>
<p>The change is simply <code>assert!(true)</code> for <code>run_file(filename)</code> with the filename injected as a string.</p>
<p>From there it was just a simple matter of loading the file then adding test logic. I&#39;ll leave out the test logic for now and just show the file loading:</p>
<pre><code class="lang-rust">// tests/runner.rs

use std::fs::File;
use std::io::Read;
use std::path::Path;

include!(concat!(env!(&quot;OUT_DIR&quot;), &quot;/tests.rs&quot;));

fn run_file(name: &amp;str) {
    let mut file_path = Path::new(&quot;tests/fodder&quot;).join(name);

    file_path.set_extension(&quot;txt&quot;);

    let mut file = File::open(&amp;file_path).unwrap();

    let mut contents = String::new();
    file.read_to_string(&amp;mut contents).unwrap();
    for raw_line in contents.split(&#39;\n&#39;) {
        // do test stuff on each line
    }
}
</code></pre>
<p>And that&#39;s it! I now had a way to use another test spec format, create a test for each one, and then run those tests. All goals accomplished and is written in and using stable Rust and Cargo.</p>





            </div>
            <div class="col-sm-3 col-sm-offset-1">
              <div class="panel panel-default">
                <div class="panel-heading">
                  About
                </div>
                <div class="panel-body">
                  This is Wraithan's dev blog, primarily focusing on rust development.
                </div>
              </div>
              <div class="panel panel-default">
                <div class="panel-heading">
                  Archives
                </div>
                <div class="panel-body">
                  <ul class="list-unstyled">
                    <li>
                      <a href="#">June 2015</a>
                    </li>
                    <li>
                      <a href="#">May 2015</a>
                    </li>
                    <li>
                      <a href="#">April 2015</a>
                    </li>
                    <li>
                      <a href="#">March 2015</a>
                    </li>
                  </ul>
                </div>
              </div>
            </div>
          </div>
          
          <div class="row">
			      <div class="col-lg-12 footer text-center">
			        <p>©2015 Wraithan</p>
			      </div>
			    </div>

		    </div>
	    </div>

    </div>
    <script src="//code.jquery.com/jquery-2.1.4.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
    <script src="/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
